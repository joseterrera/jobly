add gitignore
npm init
npm install express bcypt json schema, jsonwebtoken morgan pg
create two databases one to test

adding unit test for partial update, check this step

create a table for company
add a schema for this table
create routes


cumulative project

Libraries we use on this application:

bcrypt: This is a reliable hashing algorithm.
The way it works is we tell bcrypt how many rounds of hashing we want to use. The larger the number the longer it will take to hash it.

Bcrypt has basic methods, such as compare, hash. In our app, the request.body will include a username and password, which we will need to hash, using the work factor we specified, and save to the DB.

We will later need compare the password in the database and the user's password to determine if it is valid, and if the user can be authenticated. Refer to models/user.js.


After using bcrypt to register a user and encrypt their password, we will generate a JWT token, using the sign method.
jwt.sign(payload, secret-key, jwt-options)

payload: object to store as payload of token (it could be the username for an authenticated user).
secret-key: secret string used to “sign” token
jwt-options is optional object of settings for making the token (such as expiration)

The sign method will return a string, which will be used to access protected routes or routes that need authentication.

JWT

A JWT is a self-contained method that can be used securely transmit data between two endpoints. JWTs are most commonly used for user authentication. 
When a user first logs into the application, system backend issues a JWT to the user and sends it to the client-side. This token contains a special signature that validates the token as a one issued by the system. The client stores the token in the browser and sends it with every request to the server, where the token is used to verify the user’s authentication.

A JWT consists of 3 strings separated by periods. The 3 of them are the header, payload, and the signature. Follows is an example JWT token made of these 3 parts.

```js
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteXdlYnNpdGUuY29tIiwiaWF0IjpudWxsLCJleHAiOjUxNDM3ODA4MDAwLCJhdWQiOiIiLCJzdWIiOiIiLCJpZCI6IjEyMzQ1OTEiLCJuYW1lIjoiTWFyeSBQb3BwaW5zIiwicm9sZSI6ImVkaXRvciJ9.LYKHdyKj6SnxYaRZH_ZhiW6yk31zaBQehYm4BgawH_o
```

JWT header contains metadata about the token in JSON format. 

The payload of a JWT stores information about the token and any other entity in JSON format. In our app, it would store the information in the request body.

The last part of a JWT token, the signature, is a Message Authentication Code that is used to verify the token was not modified or generated by an outsider except the authorized application servers.

So, all the data that is needed to verify the token and identify the user is stored in the token itself. There is no need to maintain any record of the token in the server, like store the token in a database as we do with sessions. This makes JWTs stateless.




In our

We user bcrypt to register a user and ecrypt their password, and check that password against that username


look for the token, verify it and add payload that we get back to the request itself.

if there is something in req.user it means it has been verified. if there is nothing, it has not been verified or there was no token.


what does returning do?
The RETURNING clause allows you to retrieve values of columns (and expressions based on columns) that were modified by an insert, delete or update. Without RETURNING, you would have to run a SELECT statement after the DML statement is completed, in order to obtain the values of the changed columns. So, RETURNING helps avoid another roundtrip to the database, another context switch in a PL/SQL block.


schemas
.Basically, the idea is to specify the data that we expect to be received from our request, to verify that correct JSON data was passed that we can then further use in our route. Keep in mind about any discrepancies when comparing it to the solution - for example, you should also define the "_token" field in the JSON data that you are expecting to be sent to the backend route (that's part of the authentication of the user).


const {
  TEST_DATA,
  afterEachHook,
  beforeEachHook,
  afterAllHook
} = require("./config");


const BCRYPT_WORK_FACTOR = 10;

   const userJobsRes = await db.query(
      `SELECT j.title, j.company_handle, a.state 
        FROM applications AS a
          JOIN jobs AS j ON j.id = a.job_id
        WHERE a.username = $1`,
      [username]
    );

    user.jobs = userJobsRes.rows;
    return user;

    check partial update on all models



    USERS

find all
how do you test on insomnia that there is authrequired?
http://localhost:3000/ GET

http://localhost:3000/:username GET


http://localhost:3000/ POST


http://localhost:3000/:username PATCH


http://localhost:3000/:username DELETE



JOB

http://localhost:3000/ GET

http://localhost:3000/ POST

http://localhost:3000/:id PATCH

http://localhost:3000/:id DELETE


AUTH
http://localhost:3000/login

COMPANIES

http://localhost:3000/ GET

http://localhost:3000/:handle GET

http://localhost:3000/ POST

http://localhost:3000/:handle PATCH

http://localhost:3000/:handle DELETE


{

"username": "test",
"password": "testing123",
"first_name": "Jose",
"last_name": "Testing",
"email": "test@yahoo.com",
"photo_url":  "https://picsum.photos/200/300",
"is_admin": true

}




user registers:
POST http://localhost:3001/users
{
	"username" : "whiskey",
  "first_name": "Whiskey",
  "password": "foo123",
  "last_name": "Lane",
  "email": "whiskey@rithmschool.com"
}


gets a token:

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndoaXNrZXkiLCJpYXQiOjE2MDU2NTc0MDZ9.8YoPbTsLsHEFrJUkgIKtOL5RFAqcln62mAgkgyNQJ5Y"
}

GET http://localhost:3001/users

